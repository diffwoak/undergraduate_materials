## 期末大作业

提交命名：三个学号+三个姓名 期末大作业.zip

期末大作业（最多可以3人一个小组）
1.作业内容
根据课程所讲授的算法，提出一种新的算法，可以是改进已有算法，或者探索不同算法的结合等。需要对所提出的算法进行实验，跟已有算法进行对比，并完成一份完整的实验报告。
2.作业提交内容
实验报告一份，不限字数。报告内容需包括但不限于详细说明算法设计思路、算法任务、实验结果、结果分析，附录附上算法代码及代码说明。
3.评分标准
算法设计思路（40%）
算法任务（10%）
实验结果（10%）
结果分析（10%）
算法代码及代码说明（10%）
按时提交（10%）
创新性（10%）
4.加分项
撰写成中文或者英文论文（10%）
5.提交截止时间
2024年7月15日24:00。



## Abstract

随着数据挖掘技术的发展，Apriori算法作为一种经典的关联规则挖掘算法，在数据分析和商业应用中得到了广泛应用。然而，Apriori算法在处理大规模数据集时存在计算复杂度高、多次扫描数据库以及内存消耗大的问题。本文针对这些问题，提出了一种Apriori算法的改进方案。该算法通过设计一种新的数据结构来减少数据库扫描次数，采用改进的剪枝策略以减少候选项集的生成。实验结果表明，改进后的算法在处理大规模数据集时具有一定的性能提升，在计算时间显示出明显优势。

## Introduction

关联规则挖掘是数据挖掘中的一个关键任务，它主要用于发现数据项集之间的关系。Apriori算法作为关联规则挖掘的经典算法，自提出以来得到了广泛应用和研究。Apriori算法的基本思想是基于频繁项集的“自底向上”生成过程。首先，算法通过扫描数据库找到所有的频繁1项集，然后在此基础上生成频繁2项集，依次类推，直到无法生成新的频繁项集。Apriori算法利用了“频繁项集的子集也是频繁项集”这一重要性质，在候选项集的生成过程中进行剪枝，以减少不必要的计算。尽管Apriori算法在理论上具有较好的性能，但在实际应用中仍然存在一些不足。首先，算法需要多次扫描数据库，这在处理大规模数据时效率较低。其次，候选项集的生成和验证过程复杂度较高，尤其是在数据稠密或高维度数据集中。此外，Apriori算法对内存资源的消耗较大，难以处理大规模数据集。

## Method

#### Apriori算法步骤

1. **生成频繁1项集**：

- 首先扫描整个事务数据库，统计每个项的出现次数。
- 将支持度大于或等于最小支持度阈值的项集合称为频繁1项集（L1）。

2. **生成候选项集**：

- 从频繁(k-1)项集生成候选k项集（Ck）。候选项集的生成遵循“连接步”和“剪枝步”：
  - 连接步：将频繁(k-1)项集中满足前(k-2)项相同的项集两两合并，生成候选k项集。
  - 剪枝步：删除候选项集中任一子集不是频繁(k-1)项集的项集。

3. **筛选频繁项集**：

- 扫描事务数据库，计算每个候选项集在数据库中的支持度。

- 将支持度大于或等于最小支持度阈值的候选项集筛选出来，形成频繁k项集（Lk）。

5. 重复步骤2、3，直到不能生成新的频繁项集为止。

#### 二进制数存储方法

参考以上Apriori算法的步骤，其中涉及数据存储的部分有事务数据库、频繁项集、候选项集；涉及数据操作的部分有统计候选项出现次数（支持度计算）、项集合并、生成子项集，以下将对这些数据存储以及计算的部分转化为二进制存储计算。

二进制数存储方法的基本思想是每个事务和项集都可以用一个二进制数表示，其中每个位（bit）代表一个具体的项。如果该位为1，表示该项在该事务或项集中存在；如果为0，表示不存在。例如我们有项：A、B、C、D，为它们分配二进制位，如下所示：A: 0001、B: 0010、C: 0100、D: 1000，则一个事务 `{A, C}` 可以表示为：0101 ，一个项集``{A, C}``也同样表示为：0101。

##### 使用步骤

1. **项的映射**：创建一个字典，将每个项映射到一个唯一的二进制位。

2. **事务的压缩表示**：遍历每个事务，将其转换为一个二进制数。

3. **生成候选项集**：

   - 频繁项生成候选项集，使用前 k-2 项相等的项，例如100110 与 010110，除了最高位的1，其他 1都处于相同位置则满足条件
   - 使用按位或生成候选项集，例如 100110 与 010110 生成 110110
   - 剪枝：判断候选项的 k-1 子集是否在 k-1 频繁项集中，例如项110110 需判断010110、100110、110010、110100是否在 3 频繁项集中

4. **支持度计数**：通过遍历事务，将事务与每个候选项进行按位和运算，结果不为0则表示事务包含该候选项

   最后同样通过计数结果筛选出频繁项集，返回继续生成候选项集，直至频繁项集为空。

#### 支持度计数遍历方案

在Apriori算法计算支持度时，若候选项集数量非常大，遍历每个候选项比对是否存在于事务中非常耗时，此时可以通过生成事务的子集，子集遍历相对候选项遍历次数低，检查每个子集是否存在于候选项集中也能进行计数。但每一轮次每个事务生成的子集数量、候选项的的长度和数量都是变化的，例如前几个轮次的事务生成子集数量会相对较少，候选项的数量会随轮次经历一个先增加后减少的过程，因此在遍历到每一个事务时，可以通过比对事务子集数量（计算组合数$$C_{n}^{k}$$）和候选项集大小来选择使用哪个遍历方案。

## Experiments

根据 Method 提到的三个点，本次实验设计比对三个方法的效果：

方法一：基础的Apriori算法（作业五实现）

方法二：应用二进制数存储方法的Apriori算法

方法三：在方法二基础上应用支持度计数遍历方案的Apriori算法

实验基于Groceries数据集，分别设置support threshold为3、4、5比较进行三个方法的比较，统计消耗时间(s)。

实验结果

| 支持度 | 方法一 | 方法二 | 方法三 |
| :----: | :----: | :----: | :----: |
|   3    |  4105  |  5076  |        |
|   4    |  1542  |  980   |  769   |
|   5    |  759   |  486   |  297   |

可视化时间消耗过程，如下显示三种方法在三个阈值：



<img src="assets\time_4.jpg" alt="time_4" style="zoom: 50%;" />

<img src="assets\time_5.jpg" alt="time_5" style="zoom:50%;" />

由图表可见，方法二和三在每一阶段的耗时都明显少于前者，验证了二进制数存储方法带来的计算效率的提高，仔细比对方法二和三的时间线，发现主要的时间消耗差异在于k = 2、3之间，可见方法三通过选择遍历方案能节省不必要的候选项集遍历，快速地完成支持度计数。

## Conclusion

实验结果表明，改进后的算法在处理大规模数据集时具有一定的性能提升，在计算时间显示出明显优势，

- 讨论实验结果，分析改进算法的优势和不足，并探讨其应用前景和可能的改进方向。

- 总结全文，重申改进算法的贡献

