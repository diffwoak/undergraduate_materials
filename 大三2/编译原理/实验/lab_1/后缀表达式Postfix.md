## 后缀表达式*Postfix*

#### 步骤一 **静态成员与非静态成员**

将类``Parser``中``int lookahead``定义为静态(**static**)

为什么静态：说明看法？静态成员好还是非静态成员好

对正确性没有影响，

实验：非静态下的正确性

#### 步骤二 **消除程序中的尾递归**

将``rest()``改为不带尾递归的等价程序（递归→循环）

（可选）：**比较消除尾递归前后程序的性能**

**首先构造一个测试数据`tc-005.infix`：我们生成了由1000001个1构成的加法输入，即 $$ \underbrace{1+1+\dots+1}_{1000001个1} $$ 该数据的输出`tc-005.postfix`为： $$ 1\underbrace{1+1+\dots+}_{1000000个1} $$ 从算法分析的角度，有无尾递归对程序的时间复杂度是基本没有影响的。在本题中，假设输入的字符串的长度为$Len$，那么无论是否有尾递归，时间复杂度均为$O(Len)$。 但是，我们知道，递归是通过栈的形式来实现的。递归调用函数本身，在函数调用的时候，每次调用时要做地址保存，参数传递等工作。如果递归调用$Len$次，就要分配$Len$次局部变量、$Len$次形参、$Len$次调用函数地址、$Len$次返回值，这势必是影响效率的。同时递归影响运行效率是一方面，还有另一个影响就是：递归层数过多会导致栈溢出，出现栈空间不足的情况。这也是内存溢出的原因，因为积累了大量的中间变量无法释放。如下图所示：**

内存不足使用以下：

```
java -Xss515m Postfix < ..\testcases\tc-005.infix
```

#### 步骤三 **为程序扩展错误处理功能**

含有空格、运算量之间缺运算符、运算符左右缺运算量

- 给报错信息
- 给出错误位置和类别：词法错误或语法错误
- Error Recovery：搜索更多错误

```java
import java.util.ArrayList;

// 声明一个ArrayList来存储字符串
ArrayList<String> stringList = new ArrayList<>();

// 向ArrayList中添加元素
stringList.add("Element 1");
stringList.add("Element 2");
// 其他元素类似添加

// 访问ArrayList中的元素
System.out.println(stringList.get(0)); // 输出 "Element 1"

```

#### 步骤四 **为程序增加文档化注释**

javadoc生成html文档，存放在doc目录下



#### 步骤五 **程序的单元测试（可选）**



Junit对程序进行单元测试







### 思路

- 尝试比较消除尾递归后性能，包括实验数据获取，结果收集，分析最后用excel画出来，暂无解决方案
- 扩展错误解决功能：
  - 词法错误：非法字符 （除了数字和+-之外的其他字符）
  - 语法错误：不匹配 （运算符之间缺少数字，数字之间缺少运算符）
  - 非法字符直接读取下一个， 语法错误报错后，将当前字符作为合法



[后缀表达式Postfix - Birdie的博客 | Birdie Blog (birdie-go.github.io)](https://birdie-go.github.io/2022/05/09/后缀表达式Postfix/)