## 并行程序设计与算法第四次作业

### 1 简答题

##### 习题1

假定在Bleeblon计算机上，浮点型变量能够存储小数点后3位数字，它的浮点寄存器可以存储小数点后4位，并且在任意的浮点操作后，结果在存储前被四舍五人为小数点后3位。现在假设一个C程序声明了一个数组:

float a[]=4.0,3.0,3.0,1000.0;

考虑如下代码：

```c
int i;
float sum = 0.0;
# pragma omp parallel for num_threads(2) \
		reduction(+:sum)
	for(i = 0; i< 4;i++)
		sum += a[i]
		printf("sum=%4.1f\n".sum);
```

假设系统讲迭代i=0, 1分配给线程0，将迭代i=2,3分配给线程1，那么在Bleeblon计算机上，该程序的输出是什么？

程序的输出是``sum=1010.0``

##### 习题2

考虑循环

```c
a[0] = 0;
for (i=1;i<n;i++)
	a[i] = a[i-1] + 1;
```

在该程序中存在循环依赖。

(1)分析该程序中存在的循环依赖，并设计改写程序消除此依赖

循环中``a[i]`` 的正确值依赖于``a[i-1]``，如果``a[i]``在``a[i-1]``前被更新则会输出错误

消除循环依赖需要对循环进行改写，改写如下：

```c
a[0] = 0;
for(i = 1; i < n; i++)
    a[i] = i;
```

(2)加入openmp指令，对改写后的程序并行化

```c
a[0] = 0;
#pragma omp parallel for num_threads(thread_count)
for (i = 1; i < n; i++) {
    a[i] = i;
}
```

##### 习题3

我们考察8000x8000作为之前的矩阵-向量乘法程序的输人时该程序的性能。如果一个缓存行包含64字节或者8个双精度数，将输入向量表示为y，那么:

1. 假定线程0和线程2被分配给了不同的处理器，在线程0和线程2之间的伪共享（false-sharing）可不可能在向量y上发生?为什么?

对于输入向量y的大小为8000，每个线程在计算过程都会使用到向量y的每个元素，因此可能出现线程0和线程2访问同一缓存行内元素的情况，可能发生伪共享

2. 如果线程0和线程3被分配给了不同的处理器，那么伪共享（false-sharing）可不可能发生在向量y的任何地方?

同理，线程0和线程3也可能访问相邻8个内的元素，在同一缓存行上，且这种情况可能发生在y的任何地方，发生伪共享

##### 习题4

使用一维数组和openmp指令来实现并行的矩阵-向量乘法，其中矩阵为float A[m*n] ,输入向量为float x[n]，结果向量为float y[m]（手写代码给出关键的循环部分即可）

```c
#pragma omp parallel for
for (int i = 0; i < m; i++) {
    y[i] = 0.0;
    for (int j = 0; j < n; j++) {
        y[i] += A[i * n + j] * x[j];
    }
}
```

