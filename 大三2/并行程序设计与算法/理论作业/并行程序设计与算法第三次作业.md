## 并行程序设计与算法第三次作业

### 习题1

如果一个程序使用超过一个互斥量，并能够以不同的顺序来获取互斥量，程序可能会死锁。

(1)用两个线程运行程序，假设发生了下列顺序的事件，会发生什么？

Table 1:习题1(1)事件表

| 时间 |           线程0            |           线程1            |
| :--: | :------------------------: | :------------------------: |
|  0   | pthread_mutex_lock (&mut0) | pthread_mutex_lock (&mut1) |
|  1   | pthread_mutex_lock (&mut1) | pthread_mutex_lock (&mut0) |

线程0和线程1分别获得互斥量mut0和mut1，接着互相申请对方的互斥量，都在等待对方释放互斥量，陷入死锁。

(2)如果程序使用忙等待（采用两个标志变量）替代互斥量，还会有问题吗？

时间0中线程0和线程1将各自的标志变量置1，在时间1会访问检查对方的标志变量是否为0，只有为0才能访问对应的临界区，同样会不断等待对方的标准变量置0，陷入死锁。

(3)如果程序使用信号量替代互斥量，还会有问题吗？

使用信号量也是同样的情况，时间0中线程0获取sem0信号量、线程1获取sem1信号量，然后在时间1互相尝试获取对方的信号量，陷入死锁。

### 习题2

考虑一个链表以及对链表进行的操作，下列的哪些操作可能会导致问题，如果会导致问题，请举例说明：

(1)两个Delete操作同时进行

如果没有进行同步互斥的操作，一个线程删除了另一个线程即将要删除的节点，可能导致数据不一致或错误的删除

(2)一个Insert和一个Delete操作同时进行

一个线程在插入节点时，该节点的前后节点正在被另一个线程删除，可能会导致该插入节点前后指向指针失效的问题

(3)一个Member（查询一个节点是否存在）和一个Delete操作同时进行

同时进行查询和删除对删除操作没有影响，但查询可能因为与delete的前后执行关系而查找不到内容

(4)两个Insert同时进行

如果两个节点同时插入链表中同一个位置，这可能会导致先插入的节点被后插入的节点覆盖

(5)一个Insert和一个Member同时进行

同时进行插入和查询对插入操作没有影响，但可能因为操作先后顺序导致查询结果不一致的情况

### 习题3

链表操作Insert和Delete可以拆成两个阶段，第一阶段两个操作都先找到要操作节点的位置，在第二阶段才插入或删除一个节点；也即第一阶段都只涉及对链表的读访问，只有第二阶段才写访问链表。如果在第一阶段使用一个读锁来锁链表，在第二阶段使用一个写锁来锁链表，假设该读写锁的实现是【获取写锁需要先释放读锁】，这样是否安全？

这是安全的，通过获取读锁来访问列表查询节点位置能够有效防止write starvation问题，提高链表操作的并发性，只有在第二阶段修改链表时才使用写锁，确保在写操作时阻塞其他线程对该节点的读写操作，防止并发冲突。

### 习题4

在矩阵-向量乘法的例子中，采用8000*8000的输入，假设程序用4个线程运行，线程0和线程2被分配到不同的处理器上运行。如果一个缓存行大小为64字节或8个double数，在线程0和线程2之间会对向量y的任何一部分发生伪共享吗？如果线程0和线程3被分配到不同的处理器，会发生伪共享吗？

输出向量y的大小为8000，根据线程按顺序划分向量y，每个线程划分2000个double数，而一个缓存行只包括8个double数，线程0和线程2之间相隔超过一个缓存行的范围，在不同处理器运行，不会发生伪共享，同理线程0和线程3在不同处理器也不会发生伪共享

### 习题5

在矩阵-向量乘法的例子中，采用8*8 000 000的输入，假设一个缓存行的大小与习题4相同，同时假设系统有2个双核处理器，假设同一个处理器上的所有核共享一个缓存。

(1)如果只考虑一对线程共享一个处理器，可以有多少种不同的方式将4个线程分配到处理器上？

（0，1）（2，3）

（0，2）（1，3）

（0，3）（1，2）共 3 种方式

(2)在第(1)问的线程分配方式中，是否有一种线程分配方式以及一种向量元素到缓存行的分配方式，使得没有伪共享的发生？关于向量元素到缓存行的分配方式的说明：如下所示为两种不同的分配方式

<img src="https://gitee.com/e-year/images/raw/master/img/202404081434155.png" alt="image-20240408143411498" style="zoom:67%;" />

存在分配方式，因为y的8个元素始终在缓存行大小范围内，需要分为2个缓存行避免伪共享，使不同处理器分配的元素不在一个缓存行内

线程负责负责y向量为 0:[0,1] 1:[2,3]  2:[4,5] 3:[6,7]

线程分配方式：线程0、1分配到处理器1，线程2、3分配到处理器2

向量元素到缓存行的分配方式：

| y[0] | y[1] | y[2] | y[3] |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      | y[4] | y[5] | y[6] | y[7] |

