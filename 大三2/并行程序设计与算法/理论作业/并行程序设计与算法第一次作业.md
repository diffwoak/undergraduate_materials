## 并行程序设计与算法第一次作业

### 1 简答题

##### 习题1

为全局总和例子中的 my_first_i 和 my_last_i 推导一个公式。

n表示求和数量，p表示并行核数

① n能被p整除

$$avg\_ele = \frac{n}{p}$$

$$my\_first\_i=core\_id * avg\_ele$$

$$my\_last\_i=(core\_id+1) * avg\_ele-1$$

②n不能被p整除

$$avg\_ele = \lceil\frac{n}{p}\rceil$$

$$my\_first\_i=core\_id * avg\_ele$$

$$my\_last\_i=min((core\_id+1) * avg\_ele-1,n-1)$$

##### 习题2

1. 解释局部性原理

局部性分为时间局部性和空间局部性，时间局部性是指程序对某个数据的访问之后不久再次访问同一数据，即短时间内反复访问同一数据的行为；空间局部性指的是程序在访问某个数据时，很可能会再访问相邻的数据，体现在程序对连续内存位置的访问。

2. 代码存在何种局部性？

代码存在空间局部性，在循环对z[10000]中的连续位置进行访问数据。

也存在时间局部性，在循环内也就是一段时间内对sum进行反复访问执行加法操作。

##### 习题3

1. CPU写入缓存，缓存值与主存值可能不一致，有哪两种解决策略？

① write-through策略：在执行写操作时将数据同时写入缓存和主存，保证数据一致性，但频繁写入主存也会增加程序传输量和延迟

② write-back策略：在执行写操作时只写入缓存，只有在缓存中数据被替换掉时，才将数据写回主存，减少了主存访问次数

2. 阐述cache的三种映射方式

① 直接映射：将主存中每个块映射到缓存中的特定位置，这个位置由主存地址的一部分直接确定，容易将多个主存块映射到同一缓存位置，导致数据替换

② 全相联映射：主存的每个块能够映射到缓存的任意位置，能够充分使用缓存空间，但也会导致访问速度变慢

③ 组相联映射：将缓存分为多个组，每个组中包括多个行，主存块根据主存位置映射到特定缓存组，在缓存组中以全相联的方式存放。结合了直接映射和全相联映射的，降低了多次冲突替换成本同时保留了查找缓存位置一定灵活性。

##### 习题4

在冯诺伊曼体系中加入什么能够改变SISD系统的类型吗？

SISD指的是同时只有一条指令处理一条数据流，

①缓存和虚拟内存

加入缓存只是提供暂时存储数据的存储器，以减少主存访问，并不能改变SISD系统类型；虚拟内存只是结合磁盘存储提供更大的地址空间，使系统更有效地管理内存资源，但也没有改变SISD的系统类型

②流水线

流水线实现了同时处理不同指令的不同阶段，虽然提高了指令的并行度，但每个阶段只处理一个指令的数据，仍处于SISD结构

③多发射或硬件多线程

多发射指同时发射多条指令到不同的执行单元，提升了指令级并行度，硬件多线程使处理器在一段时间内交替执行多个线程，提升了线程级并行度。但仍属于SISD结构，因为CPU仍然只能一次执行一条指令的数据。

### 2 计算题

##### 习题5

对课本1.3节例子，推导公式求出0号核执行接收与加法操作的次数（24个加数、p个核）

a. 第一种计算全局总和的算法

接收：$$p-1$$次

加法：$$\lceil\frac{24}{p}\rceil+p-1$$次

b. 第二种计算全局总和的算法（树形结构）

接收：$$log_2 p$$次

加法：$$\lceil\frac{24}{p}\rceil+log_2 p$$次

c. 制表比较两种算法在核数为2、4、8、...、1024时的0号核执行接收与加法的次数

可以看出，随着核数增加，两种算法的接收次数都增加，其中第二种算法的接收次数不会随核数发生较大变化；加法操作次数随核数增加都经历了减少到增大的过程，同样第二次算法波动不大，且接收核加法次数都不大于第一种算法

| 核数 | 1：接收 | 1：加法 | 2：接收 | 2：加法 |
| ---- | ------- | ------- | ------- | ------- |
| 2    | 1       | 13      | 1       | 13      |
| 4    | 3       | 9       | 2       | 8       |
| 8    | 7       | 10      | 3       | 6       |
| 16   | 15      | 17      | 4       | 6       |
| 32   | 31      | 32      | 5       | 6       |
| 64   | 63      | 64      | 6       | 7       |
| 128  | 127     | 128     | 7       | 8       |
| 256  | 255     | 256     | 8       | 9       |
| 512  | 511     | 512     | 9       | 10      |
| 1024 | 1023    | 1024    | 10      | 11      |

##### 习题6

课本2.2.3节实例种缓存读取二维数组的示例中，换为MAX=8，即$$A[8][8]$$,缓存可存储4个缓存行，一个缓存行能存储4个元素。

① 第一种嵌套方法：实现访问$$A[0][0]$$发生Cache缺失，并将$$A[0][0],A[0][1],A[0][2],A[0][3]$$读入缓存因此接下来三次访问不会Cache缺失，在$$A[0][4]$$时发生Cache缺失，同样再次读入接下来三个元素到缓存第二行，一共四个缓存行，以此类推，在读到A的第二行结束会占用所有缓存行，接下来的读取会发生缺失并替换数据，A的每行均发生2次Cache缺失，因此发生16次失效

② 第二种嵌套方法：第一次循环从$$A[0][0],A[1][0]$$读到$$A[7][0]$$，其中每次读取都失效并将失效位置连同后三个位置比如$$A[0][0],A[0][1],A[0][2],A[0][3]$$读入缓存行，读到$$A[3][0]$$时便将缓存占满，之后读入继续失效进行缓存替换，同样第二次循环读入$$A[0][1]$$不在缓存行中，发生失效，以此类推，所有的读取均发生失效，共64次